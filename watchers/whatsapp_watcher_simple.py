#!/usr/bin/env python3
"""
Simple WhatsApp Watcher - Reads message previews from chat list

This version doesn't click through chats - it just reads the message
previews visible in the chat list sidebar.
"""

import sys
import time
import argparse
import logging
from pathlib import Path
from datetime import datetime
from typing import List, Dict

try:
    from playwright.sync_api import sync_playwright
except ImportError:
    print("Error: Playwright not installed.")
    print("Please run:")
    print("  pip install playwright")
    print("  playwright install chromium")
    sys.exit(1)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

class SimpleWhatsAppWatcher:
    """Simple watcher that reads message previews from chat list."""

    KEYWORDS = ['urgent', 'asap', 'invoice', 'payment', 'help', 'watch']

    def __init__(self, vault_path: str, session_path: str):
        self.vault_path = Path(vault_path).resolve()
        self.needs_action = self.vault_path / 'Needs_Action'
        self.needs_action.mkdir(parents=True, exist_ok=True)
        self.session_path = Path(session_path).resolve()
        self.processed_messages = set()

    def check_for_keywords(self, page) -> List[Dict]:
        """Check chat list for messages with keywords."""
        messages = []

        # Use JavaScript to scan chat list
        results = page.evaluate(f"""(keywords) => {{
            const messagesFound = [];

            // Look for any elements with text in the sidebar
            const side = document.querySelector('#side') || document.body;
            const allElements = Array.from(side.querySelectorAll('*'));

            // Find elements containing our keywords
            allElements.forEach(el => {{
                const text = el.innerText || '';
                const textLower = text.toLowerCase();

                // Check if any keyword is in the text
                const hasKeyword = keywords.some(kw => textLower.includes(kw));

                if (hasKeyword && text.trim().length > 10 && text.length < 500) {{
                    // Get context - try to find the chat/contact name
                    let sender = 'Unknown';

                    // Try to find a parent with a title or name
                    let parent = el.parentElement;
                    let attempts = 0;
                    while (parent && attempts < 5) {{
                        const titleEl = parent.querySelector('[title], [data-testid="chat-title"], span[title]');
                        if (titleEl && titleEl.innerText && titleEl.innerText.trim()) {{
                            sender = titleEl.innerText.trim().split('\\n')[0];
                            break;
                        }}
                        parent = parent.parentElement;
                        attempts++;
                    }}

                    messagesFound.push({{
                        sender: sender,
                        content: text,
                        hasKeywords: keywords.filter(kw => textLower.includes(kw))
                    }});
                }}
            }});

            return messagesFound;
        }}""", self.KEYWORDS)

        for result in results:
            messages.append({
                'id': f"WHATSAPP_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                'sender': result['sender'],
                'content': result['content'],
                'keywords': result['hasKeywords'],
                'timestamp': datetime.now().isoformat()
            })

        return messages

    def create_action_file(self, item: Dict) -> Path:
        """Create action file in Needs_Action folder."""
        # Create a unique ID based on sender + content (avoid duplicates)
        content_hash = hash(f"{item['sender']}_{item['content'][:50]}")
        filename = f"WHATSAPP_{content_hash % 100000}.md"
        filepath = self.needs_action / filename

        if filepath.exists():
            logger.debug(f"Action file already exists: {filename}")
            return None

        content = f"""---
type: whatsapp_message
source: simple_watcher
priority: high
status: pending
created: {item['timestamp']}
---

# WhatsApp Message Detected

## From: {item['sender']}

## Message Preview

{item['content']}

## Detected Keywords

{', '.join(item['keywords'])}

## Note
This is a message preview from the chat list. Open WhatsApp to see the full conversation and respond.

---
*Generated by Simple WhatsApp Watcher*
"""

        filepath.write_text(content, encoding='utf-8')
        logger.info(f"Created action file: {filename}")
        return filepath


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Simple WhatsApp Watcher")
    parser.add_argument("--vault", default=".", help="Path to Obsidian vault")
    parser.add_argument("--session", default="./whatsapp_session", help="Browser session path")
    parser.add_argument("--once", action="store_true", help="Check once and exit")
    args = parser.parse_args()

    watcher = SimpleWhatsAppWatcher(args.vault, args.session)

    print("\n" + "="*60)
    print("SIMPLE WHATSAPP WATCHER")
    print("="*60)
    print(f"Keywords: {', '.join(watcher.KEYWORDS)}")
    print("\n[*] Opening WhatsApp Web...\n")

    with sync_playwright() as p:
        browser = p.chromium.launch_persistent_context(
            user_data_dir=watcher.session_path,
            headless=False,
            args=['--no-sandbox', '--disable-blink-features=AutomationControlled']
        )

        if len(browser.pages) == 0:
            page = browser.new_page()
        else:
            page = browser.pages[0]

        page.goto('https://web.whatsapp.com', timeout=60000)
        time.sleep(10)  # Wait for page to load

        print("[*] Scanning chat list for keywords...\n")

        messages = watcher.check_for_keywords(page)

        print(f"[*] Found {len(messages)} messages with keywords\n")

        for i, msg in enumerate(messages, 1):
            print(f"{i}. From: {msg['sender']}")
            print(f"   Keywords: {', '.join(msg['keywords'])}")
            print(f"   Preview: {msg['content'][:100]}...")
            watcher.create_action_file(msg)
            print()

        print("="*60)
        print(f"Done! Created {len(messages)} action files")
        print("="*60)

        time.sleep(5)  # Keep browser open for 5 seconds
        browser.close()


if __name__ == "__main__":
    main()
