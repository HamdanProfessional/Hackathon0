#!/usr/bin/env python3
"""
File System Watcher - Monitor Drop Folder for New Files

Watches a specified folder for new files/directories and automatically
copies them to the Needs_Action folder for processing.

This is the implementation shown in Hackathon0.md (line 328).

Usage:
    python -m watchers.filesystem_watcher --vault . --watch-folder ./Inbox
    python -m watchers.filesystem_watcher --vault . --watch-folder ./Inbox --once
"""

import sys
import time
import argparse
import logging
import shutil
from pathlib import Path
from datetime import datetime
from typing import Optional

try:
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler, FileCreatedEvent, DirCreatedEvent
except ImportError:
    print("Error: watchdog not installed.")
    print("Please run: pip install watchdog")
    sys.exit(1)

from watchers.base_watcher import BaseWatcher

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class DropFolderHandler(FileSystemEventHandler):
    """
    Handles file system events for the drop folder.

    When a new file is created, it automatically copies it to the
    Needs_Action folder and creates metadata.
    """

    def __init__(self, vault_path: str, needs_action_folder: str = "Needs_Action"):
        """
        Initialize the drop folder handler.

        Args:
            vault_path: Path to Obsidian vault
            needs_action_folder: Name of action folder (default: Needs_Action)
        """
        self.vault_path = Path(vault_path)
        self.needs_action = self.vault_path / needs_action_folder
        self.needs_action.mkdir(parents=True, exist_ok=True)

        logger.info(f"Drop folder handler initialized")
        logger.info(f"Vault: {self.vault_path}")
        logger.info(f"Needs Action: {self.needs_action}")

    def on_created(self, event):
        """
        Called when a file or directory is created.

        Args:
            event: FileSystemEvent object
        """
        # Skip directories
        if event.is_directory:
            logger.debug(f"Skipping directory: {event.src_path}")
            return

        try:
            source = Path(event.src_path)
            logger.info(f"New file detected: {source.name}")

            # Create destination filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            dest_filename = f"FILE_{timestamp}_{source.name}"
            dest = self.needs_action / dest_filename

            # Copy file to Needs_Action
            shutil.copy2(source, dest)
            logger.info(f"Copied to: {dest_filename}")

            # Create metadata file
            self.create_metadata(source, dest.with_suffix('.md'))

            # Log the action
            self.log_action(source, dest)

        except Exception as e:
            logger.error(f"Error processing file {event.src_path}: {e}")

    def create_metadata(self, source: Path, dest_md: Path):
        """
        Create metadata markdown file for the dropped file.

        Args:
            source: Original source file path
            dest_md: Path to metadata file (will have .md extension)
        """
        try:
            # Get file stats
            file_size = source.stat().st_size
            file_size_mb = file_size / (1024 * 1024)

            # Determine file type
            file_ext = source.suffix.lower()
            file_type = self._get_file_type_description(file_ext)

            content = f"""---
type: file_drop
source: filesystem_watcher
original_name: {source.name}
original_path: {str(source)}
file_size: {file_size} bytes ({file_size_mb:.2f} MB)
file_type: {file_type}
created: {datetime.now().isoformat()}
status: pending
---

# File Drop Detected

## File Information

- **Original Name:** {source.name}
- **File Size:** {file_size:,} bytes ({file_size_mb:.2f} MB)
- **File Type:** {file_type}
- **Dropped At:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Suggested Actions

- [ ] Review the file content
- [ ] Determine what processing is needed
- [ ] Move to /Plans/ if complex processing required
- [ ] Archive to /Done/ after processing

## File Location

The file has been copied to:
```
{dest_md.parent / dest_md.stem.replace('.md', '')}
```

---

*Generated by File System Watcher*
"""

            dest_md.write_text(content, encoding='utf-8')
            logger.info(f"Created metadata: {dest_md.name}")

        except Exception as e:
            logger.error(f"Error creating metadata: {e}")

    def log_action(self, source: Path, dest: Path):
        """
        Log the file drop action to today's log file.

        Args:
            source: Source file path
            dest: Destination file path
        """
        try:
            from utils.audit_logging import AuditLogger

            audit_logger = AuditLogger(self.vault_path)
            audit_logger.log_action(
                action_type="file_drop",
                target=str(source.name),
                parameters={
                    "source_path": str(source),
                    "dest_path": str(dest),
                    "file_size": source.stat().st_size,
                    "file_type": source.suffix
                },
                result="success"
            )

        except Exception as e:
            logger.debug(f"Could not log to audit log: {e}")

    def _get_file_type_description(self, extension: str) -> str:
        """
        Get human-readable description of file type.

        Args:
            extension: File extension (with dot, e.g., '.pdf')

        Returns:
            Description string
        """
        type_map = {
            '.pdf': 'PDF Document',
            '.doc': 'Microsoft Word (Legacy)',
            '.docx': 'Microsoft Word',
            '.xls': 'Microsoft Excel (Legacy)',
            '.xlsx': 'Microsoft Excel',
            '.ppt': 'Microsoft PowerPoint (Legacy)',
            '.pptx': 'Microsoft PowerPoint',
            '.txt': 'Plain Text',
            '.md': 'Markdown Document',
            '.jpg': 'JPEG Image',
            '.jpeg': 'JPEG Image',
            '.png': 'PNG Image',
            '.gif': 'GIF Image',
            '.mp4': 'MP4 Video',
            '.mp3': 'MP3 Audio',
            '.zip': 'ZIP Archive',
            '.csv': 'CSV Data',
            '.json': 'JSON Data',
            '.xml': 'XML Data',
        }

        return type_map.get(extension.lower(), f'{extension.upper()} File')


class FileSystemWatcher(BaseWatcher):
    """
    Monitors a drop folder for new files.

    Uses the watchdog library to efficiently monitor file system events.
    """

    def __init__(self, vault_path: str, watch_folder: str, check_interval: int = 60):
        """
        Initialize the file system watcher.

        Args:
            vault_path: Path to Obsidian vault
            watch_folder: Path to folder to watch (absolute or relative to vault)
            check_interval: Not used for watchdog but kept for BaseWatcher compatibility
        """
        super().__init__(vault_path, check_interval)

        # Resolve watch folder path
        watch_path = Path(watch_folder)
        if not watch_path.is_absolute():
            watch_path = self.vault_path / watch_path

        self.watch_folder = watch_path
        self.watch_folder.mkdir(parents=True, exist_ok=True)

        # Create event handler
        self.event_handler = DropFolderHandler(str(self.vault_path))

        # Create observer
        self.observer = Observer()
        self.observer.schedule(self.event_handler, str(self.watch_folder), recursive=False)

        logger.info(f"File system watcher initialized")
        logger.info(f"Watching: {self.watch_folder}")

    def check_for_updates(self):
        """
        Not used in watchdog mode - observer handles events.

        This is kept for compatibility with BaseWatcher interface.
        """
        # Watchdog handles events asynchronously
        return []

    def create_action_file(self, item):
        """
        Not used in watchdog mode - event handler creates files.

        This is kept for compatibility with BaseWatcher interface.
        """
        return None

    def get_item_id(self, item):
        """
        Get unique ID for a file item.

        Required by BaseWatcher abstract class.

        Args:
            item: File path (Path object)

        Returns:
            Unique ID string for the file
        """
        if isinstance(item, str):
            item = Path(item)

        # Use filename and modification time as ID
        mtime = item.stat().st_mtime if item.exists() else 0
        return f"file_{item.name}_{int(mtime)}"

    def run(self):
        """
        Start the file system watcher.

        This blocks and watches for file system events until interrupted.
        """
        logger.info("Starting file system watcher...")
        logger.info(f"Monitoring folder: {self.watch_folder}")
        logger.info("Press Ctrl+C to stop")

        try:
            # Start the observer
            self.observer.start()

            # Keep the script running
            while True:
                time.sleep(1)

        except KeyboardInterrupt:
            logger.info("\nStopping file system watcher...")
            self.observer.stop()
            self.observer.join()
            logger.info("File system watcher stopped")

        except Exception as e:
            logger.error(f"Error in file system watcher: {e}")
            self.observer.stop()
            self.observer.join()


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Monitor a folder for new files and auto-process them"
    )

    parser.add_argument(
        "--vault",
        default=".",
        help="Path to Obsidian vault"
    )

    parser.add_argument(
        "--watch-folder",
        required=True,
        help="Path to folder to watch for new files (e.g., ./Inbox)"
    )

    args = parser.parse_args()

    print("\n" + "="*60)
    print("FILE SYSTEM WATCHER")
    print("="*60)
    print(f"\nVault: {args.vault}")
    print(f"Watching: {args.watch_folder}")
    print(f"\n[*] Monitoring for new files...")
    print("[*] Press Ctrl+C to stop\n")
    print("="*60 + "\n")

    # Create and start watcher
    watcher = FileSystemWatcher(
        vault_path=args.vault,
        watch_folder=args.watch_folder
    )

    watcher.run()


if __name__ == "__main__":
    main()
